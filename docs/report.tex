\documentclass[a4paper,10pt]{article}
\usepackage[margin=2cm]{geometry}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage[all]{hypcap}
\usepackage{tabu}
\usepackage[title,titletoc,toc]{appendix}
\usepackage[english]{babel}
\usepackage{fontspec}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{microtype}

\setlength{\headheight}{15.2pt}
\pagestyle{fancy}
\lhead{}
\chead{}
\rhead{\bfseries Phase 4 Documentation}
\lfoot{Team Bravo Integration Testing}
\cfoot{COS301 Software Engineering}
\rfoot{Page \thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}

\frenchspacing

\title{\includegraphics[width=12cm]{Eeufeeslogo.jpg} \\
       Testing and Review Report \\
       on Team Bravo Integration Repository Code \\
       \vspace{0.5cm}
       COS301 Software Engineering \\
       Research Paper Management System \\
       University of Pretoria \\
       \vspace{1.0cm}
       }

\date{}
\author{Team Echo\\
	\vspace{0.5cm} \\
	\begin{tabu} to \textwidth { X[l] X[l]}
		\hline
		\textbf{Surname, First Name (Initial)}	& \textbf{Student Number}	\\ \hline \hline
		11089777		&		Broekman, Andrew (A)			\\ \hline
		12153983		&		Andrews, Stuart (SD)			\\ \hline
		13133064		&		Shneier, Jedd (J)				\\ \hline
		14006512		&		Singh, Emilio (E)				\\ \hline
		14009936		&		Cromhout, Reinhardt (RR)			\\ \hline
		14040426		&		Loreggian, Fabio (FR)			\\ \hline
		14077893		&		Jita, Hlengekile (H)				\\ \hline
		14101263		&		van Wyk, Gerard (GJ)			\\ \hline
		14214742		&		Botha, Matthew (MT)			\\ \hline
		14446619		&		Buffo, Gian Paolo (GP)				\\ \hline
		\hline
	\end{tabu}}

\begin{document}
\maketitle
\thispagestyle{empty}
\clearpage

\newpage
\pagenumbering{roman}
\thispagestyle{empty}
\tableofcontents
\clearpage

\newpage
\pagenumbering{arabic}

\section{Background}
The client, Vreda Pieterse, from the University of Pretoria has requested a system to keep track of research publications in the Department of Computer Science at the University of Pretoria. The scope of the system is managing the administration involved in tracking of research publications within the department. However, collaboration on research papers is outside of the scope as a version control system is in use currently. The system is required to keep track of all publications and the associated metadata around the publications.

This report evaluates the implementation of the support research system by the Bravo Integration team of phase 3. This report specifically evaluates whether the team has complied with the stated functional and architecture requirements as set out in the respective documents provided by the client.

The source code reviewed can by found at the following Github repository \url{https://github.com/DillonHeins/Bravo}
\section{Functional Testing Report}
\subsection{Notifications}
According to the Application Requirements and Design Specifications, the notifications module was intended to be responsible for sending messages to users. this includes
\begin{itemize}
	\item Once-off Messages
	\item Reminder Messages
\end{itemize}
\subsubsection{Reminder Notifications}
The purpose of the Reminder Notifications was to be that users could schedule general reminders for themselves, which would be sent to the user, when the date set for the reminder holds true with the current date.

\begin{itemize}
	\item The structure and the level to which this was implemented appears to be quite rudimentary.
	\item However, through the manipulation of a string, the user would in fact receive some message stating the details of the appointment, or deadline that the given reminder relates to.
	\item Even though a user would in fact receive a message, the mock object did not cater for a date. So the user would receive the message forthwith, rather than when the user actually specified.
\end{itemize}
\subsubsection{Activity Notifications}
The purpose of the Activity Notifications, in accordance with the Application Requirements and Design Specifications, was to be used by users to be notified of any changes made to publications on which they had contributed as an author.

\begin{itemize}
	\item This was not implemented in the Notification section.
\end{itemize}
\subsubsection{Report Notifications}
According to the Application Requirements and Design Specifications, this was to be used by users (particularly by group leaders like research group leaders and the head of department) to automatically get a publications report on a group sent.

\begin{itemize}
	\item The notifications returns a string similar to Reminder's.
	\item Inlcuded in the string was a string referring to the attached file which contains the report. No mock file was included.
	\item In the Notification UML displays the Report Notification as being composed of the Schedule class diagram. No such relationship is provided in the case of Report Notifications.
\end{itemize}
\subsubsection{Broadcast Notifications}
Once again in accordance with the Application Requirements and Design Specifications, this was to be used by group leaders or administration to send scheduled broadcast
messages.

\begin{itemize}
	\item Broadcast Notifications were not implmented.
\end{itemize}
\subsection{People}

\subsection{Publications}
According to the functional requirements, the publications module should provide the functionality of maintaining information to track publications through their life cycle, from being envisaged to ultimately being either published or abandoned.
\subsubsection{addPublication}
The addPublication service should create a new publication with its own state trace represented by a time-ordered sequence of state entries. It should accept an AddPublicationRequest as an argument and return an AddPublicationResponse.

This service was correctly defined in the Publications interface. However, the request and response objects were not implemented. As such, the post conditions for this service contract were not met: a publication with an initial state entry was not created, it was not persisted, and author users who requested notifications were not notified of the creation of the publication.

A basic functioning mock object was created that checks against the pre-conditions associated with adding a new publication, such as whether a publication with the same title already exists for the same set of authors, and whether the request is valid or authorised.

A rudimentary unit test was created but did not test any actual functionality, as it merely defaulted to a failed test.

\subsubsection{changePublicationState}
A publication has a sequence of state entries representing the state trace for that publication. This is effectively an implementation of the \textit{memento} design pattern, with each state entry being a memento capturing a snapshot of the state of the publication. Therefore, changing the state of a publication should add a new state entry as described above. The changePublicationState service should accept a changePublicationStateRequest as an argument and return a changePublicationStateResponse.

This service was correctly defined in the Publications interface, and a PublicationState entity was created. However, only basic getters were implemented, in terms of retrieving the state of the latest publication. This does not allow one to view the state history of a publication. Additionally, no checks were made to see whether the person attempting to change the publication state was an author of the paper or the research leader of a research group which one or more of the authors are members of. Furthermore, no checks were made to prevent the title of the publication from being changed to a title that already exists for the authors, checking that the publication exists and ensuring that it has not yet been published. As such, none of the pre-conditions were met.

In terms of post-conditions, basic setters were implemented to alter parts of a publication, such as the publication target. However, the new publication state was not added to a sequence of state entries. Additionally, no notification functionality was implemented.

A rudimentary unit test was created but did not test any actual functionality, as it merely defaulted to a failed test.

\subsubsection{addPublicationType}
Administrators should be able to add new publication types, each with a unique name and an initial state. This state should typically be an active state to which zero or more accreditation points are assigned.

This service was correctly defined in the Publications interface. Functionality for adding a PublicationType entity was included, but contained mostly rudimentary functionality, such as returning the state of the latest publication.

The addPublicationType service should accept an addPublicationTypeRequest and return an addPublicationTypeResponse. The aforementioned request and response were not implemented. As such, the pre-conditions that users must have administrator rights and that a publication type with the same name does not exist yet were not met. Although a framework was set up to make use of the JPA, the publication type was not persisted. Thus the post-condition was not met either.

A rudimentary unit test was created but did not test any actual functionality, as it merely defaulted to a failed test.

\subsubsection{modifyPublicationType}
A publication type should also have a state that can change at any time. For example, the number of accreditation points linked to a publication type can change from some effective date onwards (while still remaining active) or by being deactivated on some effective date. It is once again important to maintain a state history so that the number of credits for a publication of a particular publication type can be correctly calculated.

This process involves creating a modifyPublicationType service, which receives a modifyPublicationTypeRequest as an argument and returns a modifyPublicationTypeRequest as a result. Once again, the service was correctly defined in the Publications interface and the request and response objects were declared, but never implemented.

The PublicationTypeState entity was created, which included provision for the effective date after which accreditation points for a specific publication type become valid.

Due to the lack of implementation, the pre-conditions regarding whether a user is an administrator or whether the given effective date is after the last effective date in the state history of a specific publication type were not met. Functionality for creating a new state entry is present, but it does not add this entry to a history of other state entries.

A rudimentary unit test was created but did not test any actual functionality, as it merely defaulted to a failed test.

\subsubsection{getPublicationsForPerson}

\subsubsection{getPublicationsForGroup}

\subsubsection{calcAccreditationPointsForPerson}

\subsubsection{calcAccreditationPointsForGroup}

\subsection{Reporting}

\subsection{Import/Export}
The following import and export requirements were outlined in the functional requirements:
\begin{itemize}
	\item Importing and exporting of persons and research groups from a CSV file
	\item Importing and exporting of publications for a person from a CSV file
	\item Exporting published papers for a user or a group to a bibtex file
\end{itemize}

None of the above requirements have been met in the system due to the fact that no import or export implementation or mocking exists.

\section{Architecture Compliance Analysis}
\subsection{Quality requirements}
\subsubsection{Flexibility}

\subsubsection{Maintainability}

\subsubsection{Scalability}

\subsubsection{Performance requirements}

\subsubsection{Reliability}

\subsubsection{Security}

\subsubsection{Auditability}

\subsubsection{Testability}

\subsubsection{Usability}

\subsubsection{Integrability}

\subsubsection{Deployability}

\subsection{Architectural responsibilities}
The team did successfully implement the Web Access architectural responsibility by providing and exposing RESTfull web services using Java EE. \\
The ProcessExecutionEnvironment responibility was addressed by the glassfish appilication server which is discussed under the heading "Architecture design \& tatics". \\
Furthermore the Reporting, PersistenceAccess, and Persistence responisbilities were not addressed by the integration team as was required. \\
The MobileDeviceAccess and BrowserAccess were both access the appliction through the Web Access responsibility.

\subsection{Architecture constraints}
The system was deployed on a Linux server and Glassfish does provide the required support for hot deployment as required.

\subsection{Architecture design}
\subsubsection{Architectural components addressing architectural responsibilities}
\begin{itemize}
	\item The ProcessExecutionEnvironment responsibility is partially fullfilled by the application server Glassfish. However the Glassfish server was not deployed as a docker image which was required.
	\item The responsibility of persisting domain objects to a database was partially implemented using JPA. Some Mock Objects used the correct annotations
	while other Mock Objects were not created at all or were not correctly annotatated Using for example the @Entity and @Id Annotations.
	\item The responsibility of providing an environment for specifying and executing reports to a reporting frame-work was not implemented.
	\item The responsibility of providing human access channels and external systems web access to the system services to a web services framework was
	implemented via RESTfull services via Java REST wrapping objects.
\end{itemize}

\subsubsection{Infrastructure}
This section analises the layered architectural pattern that should have been implemented.
\begin{itemize}
	\item The client layers were developed by submoduels and should not have been touched by die integration team.
	\item The Acces layer was provided by REST wrapping the resources via Java EE which has been discussed already.
	\item The bussiness proccess layer runs the glassfish applicaiton server which has been discussed already.
	\item The persistence Access layer was partially implemented in terms of Java JPA and not at all in terms of Jasper Reports.
	\item The persistence layer was not implemented correctly to provide a connection to a POSTGREsql database.
\end{itemize}

\subsection{Architecture design \& tatics}
\subsubsection{Flexibility}
The software architecture specification required implementation of the following flexibility tactics:
\begin{itemize}
	\item hot-deployment
	\item contract based software development with dependency injection
\end{itemize}

The Glassfish application server allows for hot-deployment of an application into a live environment.

The software architecture specification required the use of contract based software development with Java Contexts and Dependency Injection (CDI) dependency injection.  The integration team implemented the service contracts and domain models, however the implemented interfaces and domain models don't conform to the contract based software development approach.

In a contract based software development approach service contracts implement the functions which the service provider should expose with Plain Old Java Objects (POJOs) used to transport data between the database and business layer.  The integration team defined interfaces for the all POJO's and in the process did not define an interface or service contract for the service providers, against which implementations or so called realizations and mocks could be implemented against.

Further more the integration team used @EJB annotations, the old Java EE annotations for dependency injection, instead of @Injection annotations, which is the newer CDI public standard annotations.

As the integration team is using the Glassfish application server, the application server allows for maintainability through the use of dependency injection through interfaces.  However for this to work, the beans should be implemented against an interface, which the integration team failed to do, as the bean consists of only a class which derives from the java.lang.Object object. The way in which the integration team implemented their system is a cause of concern for maintainability and hot deployment, the reason being that other submodules will need to depend directly on the bean object instead of the specified service contract interface.

\subsubsection{Maintainability}
The Java EE reference architecture has various open standards which has at least one open source implementation for an application server. This will allow for future maintainability and hence satisfies the required criteria.  Further more the lack of implementing beans against a service contract, will increase the difficulty and cost of maintaining the source base.

\subsubsection{Scalability}
The use of Glassfish as an application server will deliver the required functionality of thread-pooling, object-pooling, connection-pooling and clustering as specified by the architecture requirements.

\subsubsection{Reliability}
As required by the software architecture specification all service methods should utilize managed transactions, specifically using declarative transaction annotations. The integration team however has no transaction control in the service classes, hence this quality requirement has not been met.

\subsubsection{Security}
Within the current code base there is no security implemented which implies that no declarative role based authorization or security frameworks is used within the system, in this regard the required security requirements have not been meant.

\subsubsection{Auditability}
The architecture specification required that the auditability implementation must be maintainable, and should be implemented using aspects or interceptors. The current system however has no support for auditability.

\subsubsection{Testability}
The current unit and integration tests implemented don't fully test the submodules, including the required pre- and post-conditions.  This further extends into the integration tests, which doesn't ensure that all client request conform to all pre-conditions.

The integration testing also doesn't extend to testing the database including the persistence layer, either in the application server or outside the application server using an in-memory database such as H2 or Derby.

\subsubsection{Deployability}
As the system is developed in Java, the system will be able to run on Linux servers as required by the specification, since the Java Runtime Environment is available for the Linux Operating System.  However the specification required that the application should be deployable as a Docker container,
which is not implemented by the integration team.  Hence the integration team has succeeded in partially fulfilling this requirement.

\subsection{Application component concepts and constraints}
\begin{itemize}
	\item Service Contracts\\
	The current implementation of the support research system currently makes no use service contracts for service providers. The service contracts are required by the mock implementation as well as the default implementation to allow one to switch between the different implementations using dependency injection. In the current code base this will not be possible as dependency injection is currently using the class type of the bean, and hence one will not be able to switch the mock implementation with the real implementation.

	\item Stateless Session Beans\\
	All beans implemented by the implementation team are currently set up as stateless session beans, as required by the Architecture requirment spesification.

	\item Java Entities\\
	Java Entities or so called Plain Old Java Objects are used to transport data between the database and business layer. The current Java entities used by the implementation team currently doesn't fulfil the requirements set out by the  JAVA persistence API.
\end{itemize}

\section{Persistence API}
The current POJO's utilized by the implementation team currently doesn't comply with the requirements as per the Java Persistence API.  Specifically the following requirements are not met
\begin{itemize}
	\item The classes is not annotated with the javax.persistence.Entity annotation.
	\item The classes doesn't have a public or protected no-argument constructor.
	\item The classes don't implement or extend a base entity which implement the java.io.Serializable interface.
\end{itemize}

Further more, entities also doesn't specify a primary key using the javax.persistence.Id annotation.

The current system also doesn't implement two phase commits across all services modules, which implies that the implementation only partially satisfies the required specification since it does not
properly support \textit{transactions}.

\section{Web Services Framework}
  \subsection{Architecture Requirements}
    The team adheared to the public standard and open-source implementation of their RESTful services. Thus it will be easily maintained and itegrated.
  \subsection{Architecture Design}
    The team implemented their RESTful services almost perfectly to the desing that is stipulated with Jersey, ie grouping the Peoples services into a PeoplesResource class, then defining POST, GET and PUT actions. They include all their JSON @Consumes where necessary, and JSON @Produces, but where they fell short is defining the paths within the resource and specifically with GET. The implementation required was @Path("{id}"), the retrieving the object from the ID, they however are expecting the object to to passed through the request header.


\section{Web Application Framework}
  \subsection{Architecture Requirements}
    \subsubsection{Access and Integration Requirements}
      The application is viewable on most well known browers.\\
      The team implemented integration with the REST API, but there was no backend services to connect to, so they connected to mock REST objects.
    \subsubsection{Quality Requirements}
      The site is not fully usable.\\
      Because they used to technology assigned to them Ember.js, and they created the application the correct way, it is very maintainable.\\
      The bower and ember components with the template system used, the web interface is very flexible. As it is new technology.\\
      Performance within a site that doesnt work as intended, is hard to gauge but, the technology stack provides great looking and very responsive website.
    \subsubsection{Architectural Resposibilities}
      Because the team used Emberjs with querying REST API and a template system. Most responsibilites have been met. As they provide servvices such as Navigation, Maintaing View State, User views, Integration with REST layer(only through mock objects) and Template Processing.
    \subsubsection{Architectural Constraints}
      The web interface is using open source technology such as Emberjs and Bower. And conforming to Public standards.
  \subsection{Architecture Design}
    \subsubsection{Tactics}
      \begin{itemize}
        \item Caching
        \item Templating
        \item Pre Compilation
        \item Automatic Model Population
        \item Virtual DOM
      \end{itemize}
    \subsubsection{Frameworks and Technologies}
      The team succesfully utilized Ember.js and all of its components. They unfortunately did not complete all the pages, and did not successfully implement all tactics such as virtual dom, amp and caching, but they utilixed the most important aspect which is templates. Most components within Ember.js that address the responsibilites has not been met as they do not have a fully working system.
    \subsubsection{Concepts and Constraints for application components}
      The team has successfully implemented the MVC framework which Ember requires to use, such as the Models created, the Templates used and the Controller which does not connect directly to ORM but rather through REST points.

\section{Reporting}
The current code base of the support research system currently has no reporting functionality, hence the architecture specification of needing to use Jasper Reports for reporting has not been satisfied.

\end{document}
